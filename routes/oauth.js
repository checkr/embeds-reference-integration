// This is a reference implementation for how your Checkr integration can
// authorize itself with OAuth to make requests against Checkr on your
// customer's behalf.

import express from 'express'
import database from '../db.js'
import fetch from 'node-fetch'
import {parseJSON, findAccountWithMatchingToken} from '../helpers/index.js'
import {encrypt, decrypt} from '../encryption.js'

const oauthRouter = express.Router()

// OAuth Redirect URL: Create your customer's access token
// ---------------

// When your customer wishes to sign-up with Checkr. They will click your
// [CheckrConnectLink](https://github.com/checkr/embeds-reference-integration/blob/main/client/src/components/account/CheckrConnectButton.js#L18)
// and follow the sign-up flow instructions. At the end of this flow,
// Checkr will redirect your customer to this endpoint.
oauthRouter.get('/api/checkr/oauth', async (req, res) => {
  // Checkr's redirect request will contain the following query parameters:
  // - a ```code``` variable which is generated by Checkr to create your customer's access token
  // - a ```state``` variable which you set when creating the
  //   [CheckrConnectLink](https://github.com/checkr/embeds-reference-integration/blob/main/client/src/components/account/CheckrConnectButton.js#L18).
  //   We recommend that you set the ```state``` to a value you can use to
  //   identify which customer is setting up a Checkr account. In this reference
  //   implementation, we use the customer account ID as the state variable.
  const checkrRedirectCode = req.query.code
  const customerAccountId = req.query.state

  // Next, you will request an OAuth access token from Checkr. This token will
  // be used for all your requests to Checkr on behalf of this customer. This
  // request will require the following variables:
  // - ```CHECKR_API_URL``` which is ```https://api.checkr-staging.com``` in the testing environment and ```https://api.checkr.com``` in production
  // - ```CHECKR_OAUTH_CLIENT_ID``` which is the OAuth Client ID from your [partner application](https://dashboard.checkrhq-staging.net/account/applications)
  // - ```CHECKR_OAUTH_CLIENT_SECRET``` which is the OAuth Client Secret from your [partner application](https://dashboard.checkrhq-staging.net/account/applications)
  // - ```checkrRedirectCode``` from the request query parameters sent by Checkr
  //
  // The ```CHECKR_API_URL```, ```CHECKR_OAUTH_CLIENT_ID```, and ```CHECKR_OAUTH_CLIENT_SECRET```
  // variables are taken from the app environment (via process.env) because
  // these values are different depending on whether you are using the Checkr
  // production environment or the Checkr staging environment.
  const response = await fetch(`${process.env.CHECKR_API_URL}/oauth/tokens`, {
    method: 'POST',
    body: JSON.stringify({
      client_id: process.env.CHECKR_OAUTH_CLIENT_ID,
      client_secret: process.env.CHECKR_OAUTH_CLIENT_SECRET,
      code: checkrRedirectCode,
    }),
    headers: {'Content-Type': 'application/json'},
  })
  const jsonBody = await parseJSON(response)
  if (!response.ok) {
    res.status(422).send({
      errors: {
        checkrApiErrors: jsonBody.errors,
      },
    })
    return
  }

  // A successful ```HTTP POST``` to
  // ```${process.env.CHECKR_API_URL}/oauth/tokens``` will have the following
  // response body:
  //
  //     {
  //       access_token: <access token for the customer's requests>,
  //       checkr_account_id: <your customer's Checkr account ID>,
  //     }
  //
  // Save this information along with your customer's information so that you
  // can use their access token to make Checkr requests on their behalf. The
  // ```access_token``` is a secret, and we encrypt it here to emphasize that
  // it should not be stored in plaintext.
  //
  // The ```checkr_account_id``` will be used later to record that this
  // customer's account has been credentialed by Checkr.

  const checkrAccount = {
    accessToken: await encrypt(jsonBody.access_token),
    id: jsonBody.checkr_account_id,
  }
  const db = await database()
  const account = db.data.accounts.find(a => a.id === customerAccountId)
  account.checkrAccount = checkrAccount
  await db.write()

  // After saving this information, we redirect the customer to a UI page that
  // shows them that we are waiting for Checkr to credentialize their account.
  // Their account must be credentialed before they can make any background
  // check requests with the stored OAuth access token.
  if (process.env.NODE_ENV === 'production') {
    res.status(200).sendFile('index.html', {root: '../client/build'})
  } else {
    res.status(200).redirect('http://localhost:3000/')
  }

  // After creating this OAuth Redirect endpoint, be sure to register its URL
  // as the OAuth Redirect URL in your [partner application
  // configuration](https://dashboard.checkrhq-staging.net/account/applications).
  // In localhost development environments, our
  // [Developing.md](https://github.com/checkr/embeds-reference-integration/blob/main/docs/Developing.md)
  // instructions will show you how to use [ngrok](https://ngrok.com/) to
  // create a URL for this configuration.
})

// OAuth Webhook URL: Responding to Checkr Requests
// ---------------

// Checkr will send you webhook requests with information about events that
// have occured. This endpoint is required to respond to these requests. The
// most important webhook requests when connecting a customer are the
// ```account.credentialed``` and the ```token.deauthorized``` webhooks.
oauthRouter.post('/api/checkr/webhooks', async (req, res) => {
  // To prove the integrity of each webhook request, Checkr will create a
  // signature with the request and provide it in the ```X-Checkr-Signature```
  // header. Before processing the webhook request, it's important to check the
  // validity of the header.
  const validCheckrSignature = (signature, payload) => {
    const expectedMac = createHmac('sha256', checkrClientSecret)
      .update(JSON.stringify(payload))
      .digest('hex')
    return timingSafeEqual(Buffer.from(signature), Buffer.from(expectedMac))
  }

  if (!validCheckrSignature(req.headers['x-checkr-signature'], req.body)) {
    res.status(400).send({errors: ['invalid x-checkr-signature']})
    return
  }

  // Use the webhook payload's ```type``` property to determine what to do with
  // the event.
  switch (req.body.type) {
    // #### account.credentialed webhook
    // The ```account.credentialed``` webhook is sent by Checkr to notify you
    // that the customer's Checkr account has been credentialed. Only credentialed
    // accounts can create background check requests.
    case 'account.credentialed':
      // The ```account.credentialed``` webhook payload will have an ```account_id```
      // that you can use to identify which Checkr Account has been
      // credentialed. This ```account_id``` will match the ```checkr_account_id``` from
      // the ```${process.env.CHECKR_API_URL}/oauth/tokens``` request above.
      const checkrAccountId = req.body.account_id
      const db = await database()
      const accountToCredential = db.data.accounts.find(
        a => a.checkrAccount && a.checkrAccount.id === checkrAccountId,
      )

      // Depending on your partner application's `Pre-Credentialed accounts`
      // setting, you may receive the `account.credentialed` webhook too early
      // and you may not be in the right state to receive this webhook.
      // Whenever you are not in the right state to receive a webhook, respond
      // back with the appropriate error status (in this case a 404 Checkr
      // Account Not Found). This error status will tell Checkr to retry this
      // webhook later.
      if (!accountToCredential) {
        res.status(404).send({
          errors: [
            `cannot find account with checkr account ID ${checkrAccountId}`,
          ],
        })
        return
      }

      // Once you record that this Checkr account is credentialed, you can make
      // background check requests with the access token associated with this
      // account.
      accountToCredential.checkrAccount.credentialed = true
      await db.write()

      // Successful ```HTTP Status Code 200``` responses to Checkr's webhook
      // requests will tell Checkr not to retry this webhook request.
      res.status(200).end()
      break

    // #### token.deauthorized webhook
    // The ```token.deauthorized``` webhook is sent by Checkr to notify you that
    // the customer's access token is no longer valid. This can happen when your
    // customer wishes to disable you from making background checks on their behalf.
    // <mark>All Checkr integrations are required to support this webhook.</mark>
    case 'token.deauthorized':
      // The ```token.deauthorized``` webhook payload will have the following access code
      //
      //     {
      //       data: {
      //         object: {
      //            access_code: <your customer's access token>,
      //            ...
      //         }
      //         ...
      //       }
      //       ...
      //     }
      //
      const checkrAccessToken = req.body.data.object.access_code

      // Find the customer with an access token that matches this
      // ```access_code``` value, and register this customer's Checkr Account
      // as deauthorized.
      const db = await database()
      const accountToDeauthorize = await findAccountWithMatchingToken(
        db.data.accounts,
        checkrAccessToken,
      )

      // Here, we delete the invalid Checkr account information, including the
      // ```checkrAccountId```. If your customer decides to reconnect your
      // integration with their Checkr account, the ```checkr_account_id``` and
      // ```access_token``` will be regenerated.
      delete accountToDeauthorize.checkrAccount
      accountToDeauthorize.deauthorized = true
      await db.write()
      res.status(204).end()
      break
    default:
      console.warn(`[ WARNING ] Unhandled webhook for type: ${req.body.type}`)
  }
})

// Deauthorize an access token
// ---------------

// <mark>All Checkr integrations are required to allow their customer to deauthorize
// their OAuth access token.</mark> This would disable your integration from making
// background check requests on their behalf.
oauthRouter.post('/api/checkr/deauthorize', async (req, res) => {
  // The deauthorize request to Checkr is an ```HTTP POST``` that uses basic
  // authentication. The basic auth username is the customer's access token and
  // the password is blank.
  const plaintextToken = await decrypt(req.body.encryptedToken)
  const credentials = `${Buffer.from(`${plaintextToken}:`, 'utf-8').toString(
    'base64',
  )}`
  const response = await fetch(
    `${process.env.CHECKR_API_URL}/oauth/deauthorize`,
    {
      method: 'POST',
      headers: {
        Authorization: `Basic ${credentials}`,
        'Content-Type': 'application/json',
      },
    },
  )
  if (!response.ok) {
    const jsonBody = parseJSON(response)
    res.status(422).send({
      errors: {
        checkrApiErrors: jsonBody.errors,
      },
    })
    return
  }

  // Instead of deleting the customer's access token immediately after a
  // successful deauthorization request, we wait for the subsequent
  // ```token.deauthorized``` webhook to be received. If we delete the access
  // token now, our customer's Checkr account will be in a bad state to receive
  // this webhook.
  const db = await database()
  const accountToDeauthorize = await findAccountWithMatchingToken(
    db.data.accounts,
    plaintextToken,
  )
  accountToDeauthorize.deauthorized = true
  await db.write()
  res.status(204).end()
})

export default oauthRouter
